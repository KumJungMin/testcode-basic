### 인터페이스를 기준으로 테스트를 작성하자

> 나쁜 예시

- 내부 구현에 대한 테스트는 캡슐화를 위반

```js
// bad
it('isShowModal 상태를 true로 변경했을 때 ModalComponent의 display 스타일이 block이며, "안녕하세요!" 텍스트가 노출된다.', () => {
  // 구현에 종속적인 코드와 복잡한 상태 변경 코드들이 발생
  SpecificComponent.setState({ isShowModal: true });
});
```

> 좋은 예시

- 내부 구현과 종속성이 없으며 캡슐화에 위반되지 않음
- 어떤 행위를 하는지 명확해짐
- 테스트를 설명하기 위한 불필요한 주석이나 설명 또한 없음

```js
// good
it('버튼을 누르면 모달을 띄운다. ', () => {
  //유저의 동작과 비슷하도록 클릭 이벤트를 발생
  user.click(screen.getByRole('button'));
});
```

<br/>

### 100% 테스트 커버리지에 의존하는게 맞을까?

- 테스트 작성, 실행, 유지 보수 측면에서 너무 많은 비용이 발생
- 100% 커버리지로 테스트를 작성했어도 잘못된 검증때문에 문제가 발생할 수 있음
- 커버리지 보다 어떤 범위까지 검증해야 효율적인 테스트인지, 의미있는 테스트인지 고민하자

```js
// 의미없는 코드1 - 딘순 UI 렌더링
import React from 'react';

const List = ({ items = [] }) => {
  return (
    <ul>
      {items.map ((data) => {
      return (
        <li key-{data}>{data}</li>
      );
    })}
    </ul>
  );
};
```

```js
// 의미없는 코드2 - 단순한 함수
export const isNumber = value => typeof value === 'number';
export const isString = value => typeof value === 'string';
```

<br/>

### 테스트 코드도 유지 보수의 대상! 가독성을 높이자

1. 테스트 하고자 하는 내용을 명확하게 적자

```js
// 검증 기능: 리스트에서 체크된 항목들을 삭제

//bad
it(' 리스트에서 항목이 제대로 삭제된다.', () => {});

// good
it(' 항목들을 체크한 후 삭제 버튼을 누르면 리스트에서 체크된 항목들이 삭제된다.', () => {});
```

<br/>

2. 하나의 테스트에서는 가급적 하나의 동작만 검증하자(단일 책임 원칙)

```js
// bad
it('장바구니에 담긴 상품들이 경상적으로 노출되고, 수량을 변경하면 가격이 재계산된다. 그리고 삭제 버튼을 누르면 상품이 삭제된다.', () => {});
```

```js
// good

it(' 장바구니에 담긴 상품들을 정상적으로 렌더링 한다. ', () => {});
it(' 장바구니에 담긴 상품의 수량을 수정하면 가격이 재계산된다. ', () => {});
it('장바구니에 담긴 항목의 삭제 버튼을 누르면 리스트에서 삭제된다. ', () => {});
```

<br/>

### 모든 테스트는 독립적으로 실행되어야 한다

- 테스트 순서가 바뀔 때마다 오류가 난다면, 좋은 테스트 코드가 아니다.

```js
// 상황1
it('A test', () => {});
it('B test', () => {}); // error!!

// 상활2
it('B test', () => {});
it('A test', () => {});
```
